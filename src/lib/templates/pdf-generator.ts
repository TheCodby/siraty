/**
 * PDF Generation Service
 * Converts Word documents to PDF format using direct conversion tools
 *
 * Supported Methods:
 * - LibreOffice (preferred): Direct docx-to-pdf conversion with excellent formatting preservation
 * - Pandoc (fallback): Direct docx-to-pdf conversion with good formatting support
 *
 * Best Practices Implemented:
 * - Direct conversion only (no HTML intermediary)
 * - Multiple conversion strategies with fallbacks
 * - Proper error handling and logging
 * - Memory management for large files
 * - Temporary file cleanup
 * - Security considerations
 * - Performance monitoring
 */

import { exec } from "child_process";
import { promisify } from "util";
import { promises as fs } from "fs";
import * as path from "path";

const execAsync = promisify(exec);

interface ConversionOptions {
  quality?: "low" | "medium" | "high";
  format?: "A4" | "Letter";
  margin?: {
    top: number;
    right: number;
    bottom: number;
    left: number;
  };
  timeout?: number; // in milliseconds
}

interface ConversionResult {
  success: boolean;
  buffer?: Buffer;
  method: "libreoffice" | "pandoc";
  processingTime: number;
  fileSize: number;
  error?: string;
}

export class PDFGenerator {
  private readonly tempDir: string;
  private readonly maxFileSize = 50 * 1024 * 1024; // 50MB limit
  private readonly defaultTimeout = 30000; // 30 seconds

  constructor() {
    this.tempDir = path.join(process.cwd(), "temp", "pdf");
    this.ensureTempDirectory();
  }

  /**
   * Convert Word document to PDF using the best available method
   */
  async convertWordToPDF(
    wordBuffer: Buffer,
    options: ConversionOptions = {}
  ): Promise<ConversionResult> {
    const startTime = Date.now();

    // Validate input
    if (wordBuffer.length > this.maxFileSize) {
      throw new Error(
        `File too large: ${wordBuffer.length} bytes (max: ${this.maxFileSize})`
      );
    }

    // Try direct conversion methods only (no HTML intermediary)
    const methods = [
      () => this.convertWithLibreOffice(wordBuffer, options),
      () => this.convertWithPandoc(wordBuffer, options),
    ];

    let lastError: Error | undefined;

    for (const method of methods) {
      try {
        const result = await method();
        if (result.success && result.buffer) {
          return {
            ...result,
            processingTime: Date.now() - startTime,
          };
        }
      } catch (error) {
        lastError =
          error instanceof Error
            ? error
            : new Error("Unknown conversion error");
        console.warn(`Conversion method failed:`, error);
      }
    }

    throw new Error(
      `Direct Word-to-PDF conversion failed. Please ensure LibreOffice or Pandoc is installed. Last error: ${lastError?.message}`
    );
  }

  /**
   * Convert using LibreOffice headless (preferred method)
   */
  private async convertWithLibreOffice(
    wordBuffer: Buffer,
    options: ConversionOptions
  ): Promise<ConversionResult> {
    const startTime = Date.now();

    // Create temporary files
    const tempId = `libreoffice-${Date.now()}-${Math.random()
      .toString(36)
      .substr(2, 9)}`;
    const tempWordPath = path.join(this.tempDir, `${tempId}.docx`);
    const outputDir = path.join(this.tempDir, tempId);

    try {
      // Create output directory
      await fs.mkdir(outputDir, { recursive: true });

      // Write Word buffer to temporary file
      await fs.writeFile(tempWordPath, wordBuffer);

      // Prepare LibreOffice command with options
      const timeoutMs = options.timeout || this.defaultTimeout;
      const command = [
        "soffice",
        "--convert-to",
        "pdf:writer_pdf_Export",
        "--outdir",
        `"${outputDir}"`,
        `"${tempWordPath}"`,
      ].join(" ");

      console.log(`Executing LibreOffice conversion: ${command}`);

      // Execute LibreOffice conversion with timeout
      await this.execWithTimeout(command, timeoutMs);

      // Check if PDF was created (LibreOffice creates PDF with same name as input)
      const outputPdfPath = path.join(
        outputDir,
        path.basename(tempWordPath, ".docx") + ".pdf"
      );

      let pdfBuffer: Buffer;
      try {
        pdfBuffer = await fs.readFile(outputPdfPath);
      } catch {
        // Try alternative naming conventions
        const files = await fs.readdir(outputDir);
        const pdfFile = files.find((f) => f.endsWith(".pdf"));
        if (!pdfFile) {
          throw new Error("PDF file not generated by LibreOffice");
        }
        pdfBuffer = await fs.readFile(path.join(outputDir, pdfFile));
      }

      // Cleanup
      await this.cleanup([tempWordPath, outputDir]);

      return {
        success: true,
        buffer: pdfBuffer,
        method: "libreoffice",
        processingTime: Date.now() - startTime,
        fileSize: pdfBuffer.length,
      };
    } catch (error) {
      // Cleanup on error
      await this.cleanup([tempWordPath, outputDir]);

      throw new Error(
        `LibreOffice conversion failed: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }

  /**
   * Convert using Pandoc (alternative method)
   */
  private async convertWithPandoc(
    wordBuffer: Buffer,
    options: ConversionOptions
  ): Promise<ConversionResult> {
    const startTime = Date.now();

    const tempId = `pandoc-${Date.now()}-${Math.random()
      .toString(36)
      .substr(2, 9)}`;
    const tempWordPath = path.join(this.tempDir, `${tempId}.docx`);
    const tempPdfPath = path.join(this.tempDir, `${tempId}.pdf`);

    try {
      // Write Word buffer to temporary file
      await fs.writeFile(tempWordPath, wordBuffer);

      // Prepare Pandoc command
      const margins = options.margin || {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1,
      };
      const paperSize = options.format || "A4";

      const command = [
        "pandoc",
        `"${tempWordPath}"`,
        "-o",
        `"${tempPdfPath}"`,
        "--pdf-engine=xelatex",
        `--variable=geometry:margin=${margins.top}in`,
        `--variable=papersize:${paperSize}`,
        "--variable=fontsize:11pt",
      ].join(" ");

      console.log(`Executing Pandoc conversion: ${command}`);

      const timeoutMs = options.timeout || this.defaultTimeout;
      await this.execWithTimeout(command, timeoutMs);

      // Read the generated PDF
      const pdfBuffer = await fs.readFile(tempPdfPath);

      // Cleanup
      await this.cleanup([tempWordPath, tempPdfPath]);

      return {
        success: true,
        buffer: pdfBuffer,
        method: "pandoc",
        processingTime: Date.now() - startTime,
        fileSize: pdfBuffer.length,
      };
    } catch (error) {
      // Cleanup on error
      await this.cleanup([tempWordPath, tempPdfPath]);

      throw new Error(
        `Pandoc conversion failed: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }

  /**
   * Execute command with timeout
   */
  private async execWithTimeout(
    command: string,
    timeoutMs: number
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const process = exec(command, (error, stdout, stderr) => {
        if (error) {
          reject(
            new Error(`Command failed: ${error.message}\nStderr: ${stderr}`)
          );
        } else {
          resolve();
        }
      });

      // Set timeout
      const timeout = setTimeout(() => {
        process.kill();
        reject(new Error(`Command timed out after ${timeoutMs}ms`));
      }, timeoutMs);

      // Clear timeout on completion
      process.on("exit", () => {
        clearTimeout(timeout);
      });
    });
  }

  /**
   * Check if conversion tools are available
   */
  async checkAvailableTools(): Promise<{
    libreoffice: boolean;
    pandoc: boolean;
  }> {
    const tools = {
      libreoffice: false,
      pandoc: false,
    };

    // Check LibreOffice
    try {
      await execAsync("libreoffice --version");
      tools.libreoffice = true;
    } catch {
      console.warn("LibreOffice not available");
    }

    // Check Pandoc
    try {
      await execAsync("pandoc --version");
      tools.pandoc = true;
    } catch {
      console.warn("Pandoc not available");
    }

    return tools;
  }

  /**
   * Cleanup temporary files and directories
   */
  private async cleanup(paths: string[]): Promise<void> {
    for (const filePath of paths) {
      try {
        const stats = await fs.stat(filePath);
        if (stats.isDirectory()) {
          await fs.rmdir(filePath, { recursive: true });
        } else {
          await fs.unlink(filePath);
        }
      } catch {
        // Ignore cleanup errors
      }
    }
  }

  /**
   * Ensure temp directory exists
   */
  private async ensureTempDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.tempDir, { recursive: true });
    } catch {
      console.warn("Could not create PDF temp directory");
    }
  }

  /**
   * Get recommended conversion method based on available tools
   */
  async getRecommendedMethod(): Promise<"libreoffice" | "pandoc"> {
    const tools = await this.checkAvailableTools();

    if (tools.libreoffice) return "libreoffice";
    if (tools.pandoc) return "pandoc";

    throw new Error(
      "No direct Word-to-PDF conversion tools available. Please install LibreOffice or Pandoc."
    );
  }
}
